<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>AR Video Placement</title>
  <style>
    body { margin:0; overflow:hidden; }
  </style>
</head>
<body>

<script type="module">
import {WebXRButton} from './js/util/webxr-button.js';
import {Scene} from './js/render/scenes/scene.js';
import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
import {Node} from './js/render/core/node.js';
import {Gltf2Node} from './js/render/nodes/gltf2.js';
import {MeshNode} from './js/render/nodes/mesh.js';
import {Primitive} from './js/render/core/primitive.js';
import {Material} from './js/render/core/material.js';

let xrButton;
let xrRefSpace;
let xrViewerSpace;
let xrHitTestSource;

let gl;
let renderer;
let scene = new Scene();
scene.clear = false;

let reticle;
let placedObject = null;
let objectPlaced = false;

let video;
let videoTexture;

const resetButton = document.createElement("button");
resetButton.innerText = "RESET";
resetButton.style.position = "absolute";
resetButton.style.bottom = "20px";
resetButton.style.left = "50%";
resetButton.style.transform = "translateX(-50%)";
resetButton.style.padding = "12px 20px";
resetButton.style.fontSize = "16px";
resetButton.style.display = "none";
document.body.appendChild(resetButton);
resetButton.onclick = resetPlacement;

initXR();

function initXR() {
  xrButton = new WebXRButton({
    onRequestSession,
    onEndSession,
    textEnterXRTitle: "START AR",
    textXRNotFoundTitle: "AR NOT FOUND",
    textExitXRTitle: "EXIT AR"
  });

  document.body.appendChild(xrButton.domElement);

  if (navigator.xr) {
    navigator.xr.isSessionSupported('immersive-ar')
      .then(supported => xrButton.enabled = supported);
  }
}

function onRequestSession() {
  return navigator.xr.requestSession('immersive-ar', {
    requiredFeatures: ['local', 'hit-test']
  }).then(session => {
    xrButton.setSession(session);
    onSessionStarted(session);
  });
}

function onSessionStarted(session) {

  session.addEventListener('end', () => xrButton.setSession(null));
  session.addEventListener('select', onSelect);

  gl = createWebGLContext({ xrCompatible: true });
  renderer = new Renderer(gl);
  scene.setRenderer(renderer);

  session.updateRenderState({
    baseLayer: new XRWebGLLayer(session, gl)
  });

  // Reticle model (using existing reticle gltf)
  reticle = new Gltf2Node({ url: 'media/gltf/reticle/reticle.gltf' });
  reticle.visible = false;
  scene.addNode(reticle);

  session.requestReferenceSpace('viewer').then(space => {
    xrViewerSpace = space;
    session.requestHitTestSource({ space: xrViewerSpace })
      .then(source => xrHitTestSource = source);
  });

  session.requestReferenceSpace('local').then(space => {
    xrRefSpace = space;
    session.requestAnimationFrame(onXRFrame);
  });
}

function onEndSession(session) {
  if (xrHitTestSource) xrHitTestSource.cancel();
  session.end();
}

function createVideoQuad(matrix) {

  placedObject = new Node();
  placedObject.matrix = matrix;

  video = document.createElement("video");
  video.src = "media/video.mp4";   // ðŸ”¥ CHANGE THIS TO YOUR VIDEO
  video.loop = true;
  video.muted = true;
  video.playsInline = true;
  video.crossOrigin = "anonymous";
  video.play();

  const texture = renderer.createTexture(video);
  videoTexture = texture;

  const material = new Material();
  material.baseColorTexture = texture;
  material.metallicFactor = 0;
  material.roughnessFactor = 1;

  const primitive = Primitive.createPlane();

  const mesh = new MeshNode({
    primitive,
    material
  });

  mesh.scale = [1.6, 0.9, 1];  // video aspect ratio
  placedObject.addNode(mesh);

  scene.addNode(placedObject);

  objectPlaced = true;
  reticle.visible = false;
  resetButton.style.display = "block";
}

function resetPlacement() {
  if (placedObject) {
    scene.removeNode(placedObject);
    placedObject = null;
  }

  if (video) {
    video.pause();
    video = null;
  }

  objectPlaced = false;
  resetButton.style.display = "none";
}

function onSelect() {
  if (reticle.visible && !objectPlaced) {
    createVideoQuad(reticle.matrix);
  }
}

function onXRFrame(t, frame) {
  const session = frame.session;
  const pose = frame.getViewerPose(xrRefSpace);

  if (!objectPlaced && xrHitTestSource && pose) {
    const hits = frame.getHitTestResults(xrHitTestSource);
    if (hits.length > 0) {
      const hitPose = hits[0].getPose(xrRefSpace);
      reticle.visible = true;
      reticle.matrix = hitPose.transform.matrix;
    } else {
      reticle.visible = false;
    }
  }

  // Update video texture
  if (video && video.readyState >= 2 && videoTexture) {
    videoTexture.setSource(video);
  }

  scene.startFrame();
  session.requestAnimationFrame(onXRFrame);
  scene.drawXRFrame(frame, pose);
  scene.endFrame();
}
</script>

</body>
</html>
